// the goal of this project is to reverse engineer the binary file format of the after effects ffx format in ./test-files/pseudo.ffx and create a typescript library to read and write ffx files
// the ffx file generated by this should be output to ./output/pseudo.ffx

import * as fs from "fs";
import * as path from "path";

interface FFXSection {
  type: string;
  offset: number;
  length: number;
  children: FFXSection[];
  data?: Buffer;
  value?: any;
}

class FFXStructureAnalyzer {
  private buffer: Buffer;
  private position: number = 0;

  constructor(buffer: Buffer) {
    this.buffer = buffer;
  }

  readString(length: number): string {
    if (this.position + length > this.buffer.length) {
      throw new Error(
        `Buffer overflow: Trying to read ${length} bytes at position ${this.position}`
      );
    }
    const str = this.buffer
      .slice(this.position, this.position + length)
      .toString("utf8");
    this.position += length;
    return str;
  }

  readUInt32(): number {
    if (this.position + 4 > this.buffer.length) {
      throw new Error(
        `Buffer overflow: Trying to read 4 bytes at position ${this.position}`
      );
    }
    const value = this.buffer.readUInt32BE(this.position);
    this.position += 4;
    return value;
  }

  parseSection(offset: number = 0): FFXSection | null {
    try {
      this.position = offset;

      if (this.position >= this.buffer.length) {
        return null;
      }

      // Read section header
      const type = this.readString(4);
      const length = this.readUInt32();

      // Create section
      const section: FFXSection = {
        type,
        offset,
        length,
        children: [],
      };

      // Special handling for RIFX format
      if (type === "RIFX") {
        // Read form type (should be 'FaFX')
        const formType = this.readString(4);
        section.value = formType;

        // Parse remaining content as children
        const remainingLength = length - 12; // subtract RIFX(4) + length(4) + formType(4)
        if (remainingLength > 0) {
          section.children = this.parseChildren(this.position, remainingLength);
        }
      }
      // Handle head section
      else if (type === "head") {
        // Parse head section content
        section.value = {
          version: this.readUInt32(),
          numSections: this.readUInt32(),
          unknown: this.readUInt32(),
        };
      }
      // Handle LIST sections
      else if (type === "LIST") {
        const listType = this.readString(4);
        section.value = listType;

        const remainingLength = length - 8; // subtract LIST(4) + length(4)
        if (remainingLength > 0) {
          section.children = this.parseChildren(this.position, remainingLength);
        }
      }
      // Store raw data for other sections
      else {
        section.data = this.buffer.slice(this.position, offset + length);
        this.position += section.data.length;
      }

      return section;
    } catch (error) {
      console.error(`Error parsing section at offset ${offset}:`, error);
      return null;
    }
  }

  private parseChildren(start: number, length: number): FFXSection[] {
    const children: FFXSection[] = [];
    let currentOffset = start;
    const endOffset = start + length;

    // Add safety counter to prevent infinite loops
    let safetyCounter = 0;
    const maxSections = 1000; // Adjust this number based on your needs

    while (currentOffset < endOffset && safetyCounter < maxSections) {
      const section = this.parseSection(currentOffset);
      if (!section) break;

      // Validate section length
      if (section.length <= 0 || currentOffset + section.length > endOffset) {
        console.warn(`Invalid child section length at offset ${currentOffset}`);
        break;
      }

      children.push(section);
      currentOffset += section.length;
      safetyCounter++;
    }

    if (safetyCounter >= maxSections) {
      console.warn("Maximum section limit reached, parsing stopped");
    }

    return children;
  }
}

class FFXAnalyzer {
  private buffer: Buffer;
  private structureAnalyzer: FFXStructureAnalyzer;

  constructor(filePath: string) {
    const resolvedPath = path.resolve(__dirname, "../", filePath);
    this.buffer = fs.readFileSync(resolvedPath);
    this.structureAnalyzer = new FFXStructureAnalyzer(this.buffer);
  }

  analyze(): void {
    console.log("File size:", this.buffer.length, "bytes");

    // Analyze file structure
    const structure = this.structureAnalyzer.parseSection(0);

    if (structure) {
      this.printStructure(structure, 0);
    }
  }

  private printStructure(section: FFXSection, depth: number): void {
    const indent = "  ".repeat(depth);
    console.log(`${indent}Section: ${section.type}`);
    console.log(`${indent}Offset: ${section.offset}`);
    console.log(`${indent}Length: ${section.length}`);

    // Print parsed values if available
    if (section.value !== undefined) {
      console.log(`${indent}Value:`, section.value);
    }

    // Print hex dump of the section's data
    if (section.data) {
      console.log(`${indent}Data (first 32 bytes):`);
      console.log(
        `${indent}${this.formatHexDump(
          section.data.slice(0, Math.min(32, section.data.length))
        )}`
      );

      // Try to interpret as string if it looks like text
      if (this.looksLikeText(section.data)) {
        console.log(
          `${indent}As Text: "${section.data.toString("utf8").trim()}"`
        );
      }
    }

    // Recursively print children
    section.children.forEach((child) => {
      this.printStructure(child, depth + 1);
    });
  }

  private formatHexDump(buffer: Buffer): string {
    return buffer.toString("hex").match(/.{2}/g)?.join(" ") || "";
  }

  private looksLikeText(buffer: Buffer): boolean {
    // Simple heuristic: check if the buffer contains mostly printable ASCII characters
    let printable = 0;
    for (let i = 0; i < buffer.length; i++) {
      if (buffer[i] >= 32 && buffer[i] <= 126) {
        printable++;
      }
    }
    return printable / buffer.length > 0.8;
  }
}

// Run the analyzer
const analyzer = new FFXAnalyzer("files/test-files/just-one-slider.ffx");
analyzer.analyze();
