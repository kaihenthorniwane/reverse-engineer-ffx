// the goal of this project is to reverse engineer the binary file format of the after effects ffx format in ./test-files/pseudo.ffx and create a typescript library to read and write ffx files
// the ffx file generated by this should be output to ./output/pseudo.ffx

import * as fs from "fs";
import * as path from "path";
import { FFXWriter, FFXEffect } from "./writer";

interface FFXSection {
  type: string;
  offset: number;
  length: number;
  children: FFXSection[];
  data?: any;
}

class FFXStructureAnalyzer {
  private buffer: Buffer;

  constructor(buffer: Buffer) {
    this.buffer = buffer;
  }

  parseSection(offset: number): FFXSection | null {
    const type = this.buffer.slice(offset, offset + 4).toString();

    // Get section length (4 bytes after type)
    const length = this.buffer.readUInt32BE(offset + 4);

    return {
      type,
      offset,
      length,
      children: this.parseChildren(offset + 8, length - 8),
    };
  }

  private parseChildren(start: number, length: number): FFXSection[] {
    const children: FFXSection[] = [];
    let offset = start;

    while (offset < start + length) {
      const section = this.parseSection(offset);
      if (!section) break;

      children.push(section);
      offset += section.length;
    }

    return children;
  }
}

class FFXAnalyzer {
  private buffer: Buffer;

  constructor(filePath: string) {
    // Resolve path relative to dist directory
    const resolvedPath = path.resolve(__dirname, "../files", filePath);
    this.buffer = fs.readFileSync(resolvedPath);
  }

  analyze(): void {
    console.log("File size:", this.buffer.length, "bytes");

    // Print first 32 bytes as hex for header analysis
    console.log("\nHeader (first 32 bytes):");
    console.log(
      this.buffer.slice(0, 32).toString("hex").match(/.{2}/g)?.join(" ")
    );

    // Try to detect string patterns
    this.findStrings();

    // Look for common structural patterns
    this.analyzeStructure();
  }

  private findStrings(): void {
    let currentString = "";
    console.log("\nPossible string contents:");

    for (let i = 0; i < this.buffer.length; i++) {
      const byte = this.buffer[i];
      if (byte >= 32 && byte <= 126) {
        // Printable ASCII range
        currentString += String.fromCharCode(byte);
      } else if (currentString.length > 3) {
        // Only show strings longer than 3 chars
        console.log(`Offset ${i - currentString.length}: "${currentString}"`);
        currentString = "";
      } else {
        currentString = "";
      }
    }
  }

  private analyzeStructure(): void {
    // Look for repeated patterns or known markers
    console.log("\nStructural analysis:");

    // Common markers to look for
    const markers = [
      Buffer.from([0xff, 0xfe]), // UTF-16LE BOM
      Buffer.from([0xef, 0xbb, 0xbf]), // UTF-8 BOM
      Buffer.from("RIFX"), // Common AE format marker
    ];

    markers.forEach((marker) => {
      let offset = 0;
      while ((offset = this.buffer.indexOf(marker, offset)) !== -1) {
        console.log(`Found marker "${marker.toString()}" at offset: ${offset}`);
        offset += marker.length;
      }
    });
  }
}

// Create a test effect
const testEffect: FFXEffect = {
  controlName: "Test Effect",
  matchname: "Custom/Test/Effect",
  controlArray: [
    {
      name: "Slider 1",
      type: "slider",
      matchname: "Custom/Slider/1",
      canHaveKeyframes: true,
      canBeInvisible: false,
      id: Math.floor(Math.random() * 1000000000),
      hold: false,
      default: 50,
    },
    {
      name: "Color 1",
      type: "color",
      matchname: "Custom/Color/1",
      canHaveKeyframes: true,
      canBeInvisible: false,
      id: Math.floor(Math.random() * 1000000000),
      hold: false,
      default: { red: 255, green: 0, blue: 0 },
    },
  ],
};

// Create and use the writer
const writer = new FFXWriter();
writer.writeFFX(testEffect, "output/pseudo.ffx");

// Run the analyzer on the generated file
const analyzer = new FFXAnalyzer("output/pseudo.ffx");
analyzer.analyze();
